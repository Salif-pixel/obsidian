
---


## Introduction

Ce projet vise √† d√©velopper une interface interactive pour d√©tecter les malwares √† partir de fichiers ex√©cutables (¬´ exe ¬ª). Le projet utilise un mod√®le de classification bas√© sur Random Forest optimis√© avec Optuna. L‚Äôinterface utilisateur est construite avec Streamlit et le mod√®le est d√©ploy√© en ligne via Streamlit Cloud.

## Architecture du projet

![[2024-12-22 14_33_34-Rapport sur le projet de d√©tection de malware avec Streamlit Salif Biaye - main .png]]



## D√©tails du projet

### 1. Pr√©paration des donn√©es

- **Source des donn√©es** : Le fichier `DatasetmalwareExtrait.csv` contient des caract√©ristiques extraites de fichiers ex√©cutables.
- **S√©paration des donn√©es** :
    - **X** : Caract√©ristiques
    - **y** : √âtiquette cible (`legitimate`)
    - S√©paration des donn√©es en ensembles d'entra√Ænement (90%) et de test (10%).

```python
# Charger les donn√©es  
data = pd.read_csv("./datatest/DatasetmalwareExtrait.csv")  
  
# S√©parer les caract√©ristiques (X) et la cible (y)  
X = data.drop(columns=['legitimate'])  
y = data['legitimate']  
  
# Diviser les donn√©es en ensemble d'entra√Ænement et de test  
X_train, X_test, y_train, y_test = train_test_split(  
    X, y, test_size=0.1, random_state=42, stratify=y  
)
```
### 2. Optimisation des hyperparam√®tres avec Optuna

- **Objectif** : Maximiser l‚Äôexactitude du mod√®le via validation crois√©e.
- **Hyperparam√®tres optimis√©s** :
    - Nombre d‚Äôarbres (`n_estimators`)
    - Crit√®re de scission (`criterion`)
    - Profondeur maximale (`max_depth`)
    - Nombre minimum d‚Äô√©chantillons pour une scission (`min_samples_split`)
    - Nombre minimum d‚Äô√©chantillons par feuille (`min_samples_leaf`)
    - Caract√©ristiques maximales consid√©r√©es (`max_features`)

```python
# Fonction d'optimisation Optuna  
def objective(trial):  
    # D√©finir les hyperparam√®tres √† optimiser  
    n_estimators = trial.suggest_int('n_estimators', 50, 150)  
    criterion = trial.suggest_categorical('criterion', ['gini', 'entropy'])  
    max_depth = trial.suggest_int('max_depth', 5, 50, step=5)  
    min_samples_split = trial.suggest_int('min_samples_split', 2, 20)  
    min_samples_leaf = trial.suggest_int('min_samples_leaf', 1, 10)  
    max_features = trial.suggest_categorical('max_features', ['sqrt', 'log2'])  
  
    # Initialiser le mod√®le avec ces hyperparam√®tres  
    model = RandomForestClassifier(  
        n_estimators=n_estimators,  
        criterion=criterion,  
        max_depth=max_depth,  
        min_samples_split=min_samples_split,  
        min_samples_leaf=min_samples_leaf,  
        max_features=max_features,  
        random_state=42,  
        n_jobs=-1  
    )  
  
    # Utiliser la validation crois√©e pour √©valuer le mod√®le  
    score = cross_val_score(model, X_train, y_train, cv=5, scoring='accuracy', n_jobs=-1)  
  
    # Retourner la moyenne des scores comme objectif  
    return score.mean()  
  
# Cr√©er une √©tude Optuna  
study = optuna.create_study(direction='maximize')  
  
# Lancer l'optimisation  
study.optimize(objective, n_trials=30)  
  
# Afficher les meilleurs hyperparam√®tres  
print("Meilleurs hyperparam√®tres trouv√©s :", study.best_params)  
  
# Cr√©er un mod√®le avec les meilleurs hyperparam√®tres  
best_opt_params = study.best_params
```
### 3. Entra√Ænement et sauvegarde du mod√®le

- **Mod√®le utilis√©** : RandomForestClassifier avec les meilleurs hyperparam√®tres.
- **Biblioth√®que pour la sauvegarde** : `joblib`.

```python
optimized_rf = RandomForestClassifier(**best_opt_params, random_state=42, n_jobs=-1)  
  
# Entra√Æner le mod√®le avec les donn√©es d'entra√Ænement  
optimized_rf.fit(X_train, y_train)  
  
# Sauvegarder le mod√®le optimis√©  
joblib.dump(optimized_rf, "optimized_model.pkl")  
print("Mod√®le optimis√© sauvegard√© sous 'optimized_model.pkl'.")
```
### 4. Extraction des caract√©ristiques

- Utilisation de la biblioth√®que `pefile` pour analyser les fichiers ¬´ exe ¬ª.
    
- Caract√©ristiques extraites :
    
    - Adresse du point d‚Äôentr√©e (`AddressOfEntryPoint`)
        
    - Version majeure du lieur (`MajorLinkerVersion`)
        
    - Version majeure de l‚Äôimage (`MajorImageVersion`)
        
    - Version majeure du syst√®me d‚Äôexploitation (`MajorOperatingSystemVersion`)
        
    - Caract√©ristiques des DLL (`DllCharacteristics`)
        
    - Taille de la pile r√©serv√©e (`SizeOfStackReserve`)
        
    - Nombre de sections (`NumberOfSections`)
        
    - Taille des ressources (`ResourceSize`)
    
```python
def get_resource_size(pe):  
    try:  
        if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE') and pe.DIRECTORY_ENTRY_RESOURCE.entries:  
            total_size = 0  
            for entry in pe.DIRECTORY_ENTRY_RESOURCE.entries:  
                if hasattr(entry, 'directory') and entry.directory.entries:  
                    for sub_entry in entry.directory.entries:  
                        if hasattr(sub_entry, 'data') and hasattr(sub_entry.data, 'struct'):  
                            total_size += sub_entry.data.struct.Size  
            return total_size  
        return 0  
    except Exception as e:  
        print(f"Erreur lors de l'extraction de la taille des ressources : {e}")  
        return 0  
  
  
def extract_features(executable_path):  
    try:  
        pe = pefile.PE(executable_path)  
        features = {  
            'AddressOfEntryPoint': pe.OPTIONAL_HEADER.AddressOfEntryPoint,  
            'MajorLinkerVersion': pe.OPTIONAL_HEADER.MajorLinkerVersion,  
            'MajorImageVersion': pe.OPTIONAL_HEADER.MajorImageVersion,  
            'MajorOperatingSystemVersion': pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,  
            'DllCharacteristics': pe.OPTIONAL_HEADER.DllCharacteristics,  
            'SizeOfStackReserve': pe.OPTIONAL_HEADER.SizeOfStackReserve,  
            'NumberOfSections': len(pe.sections),  
            'ResourceSize': get_resource_size(pe)  
        }  
        return features  
    except Exception as e:  
        print(f"Erreur lors de l'extraction des caract√©ristiques : {e}")  
        return None
```
### 5. Interface utilisateur avec Streamlit

- Permet de t√©l√©verser un fichier ex√©cutable.
- Affiche un message d‚Äôerreur en cas de probl√®me avec l‚Äôanalyse.
- Pr√©sente le r√©sultat de la pr√©diction (¬´ Malware ¬ª ou ¬´ Non-Malware ¬ª).

```python
# Interface Streamlit  
# Titre et image  
st.title("D√©tection de Malware avec Machine Learning")  
st.image("https://db0dce98.rocketcdn.me/wp-content/uploads/2020/11/Machine-learning-def-.png",  
         use_container_width=True)  
  
st.markdown("""  
Cette application utilise un mod√®le de machine learning pour d√©tecter si un fichier ex√©cutable est un **malware** ou **non-malware**.  
T√©l√©versez un fichier .exe et obtenez instantan√©ment une analyse.  
""")  
  
# Ajouter une section avec un fond color√©  
st.markdown("""  
<style>  
    .stButton>button {        background-color: #4CAF50;        color: white;        font-size: 18px;        height: 50px;        width: 150px;        border-radius: 10px;        margin-top: 10px;    }</style>  
""", unsafe_allow_html=True)  
  
# Ajouter un uploader de fichiers  
uploaded_file = st.file_uploader("T√©l√©versez un fichier ex√©cutable", type=["exe"])  
  
# V√©rifier si un fichier a √©t√© t√©l√©charg√©  
if uploaded_file is not None:  
    with open(f"./temp/{uploaded_file.name}", "wb") as f:  
        f.write(uploaded_file.getbuffer())  
        file_path = f"./temp/{uploaded_file.name}"  
  
    st.write("Analyse du fichier en cours...")  
  
    features = extract_features(file_path)  
  
    if features is None:  
        st.error("Erreur lors de l'extraction des caract√©ristiques.")  
    else:  
        features_df = pd.DataFrame([features])  
        prediction = model.predict(features_df)[0]  
        result = "Malware" if prediction == 1 else "Non-Malware"  
  
        # Ajout d'un graphique de r√©sultat  
        if result == "Malware":  
            st.warning(f"**R√©sultat : {result}** üõë", icon="‚ö†Ô∏è")  
        else:  
            st.success(f"**R√©sultat : {result}** ‚úÖ", icon="‚úîÔ∏è")  
  
        # Afficher plus de d√©tails ou recommandation  
        st.markdown("""  
        ### D√©tails suppl√©mentaires :        - Vous pouvez t√©l√©charger un autre fichier ou analyser un autre programme.        - Si vous avez des doutes sur un fichier, assurez-vous d'utiliser un antivirus de confiance.        """)
```

- Puis dans le terminal on tape la commande `streamlit run app.py`

```bash

Installez la derni√®re version de PowerShell pour de nouvelles fonctionnalit√©s et am√©liorations¬†! https://aka.ms/PSWindows

(base) PS C:\Users\DELL\PycharmProjects\aicours> streamlit run app.py

  You can now view your Streamlit app in your browser.

  Local URL: http://localhost:8501 
  Network URL: http://192.168.1.13:8501


```

![[2024-12-22 14_11_14-.png]]

---
![[2024-12-22 14_11_52-Streamlit ‚Äî Mozilla Firefox.png]]
### 6. D√©ploiement

- **Outil utilis√©** : Streamlit Cloud.
- **Processus** :
    1. Pousser le projet sur GitHub. https://github.com/Salif-pixel/flask-heroku-app
    2. Configurer Streamlit Cloud pour ex√©cuter l‚Äôapplication.

![[2024-12-22 14_14_14-flask-heroku-app_app.py at main ¬∑ Salif-pixel_flask-heroku-app ‚Äî Mozilla Firefox.png]]

---
![[2024-12-22 14_16_51-Rapport sur le projet de d√©tection de malware avec Streamlit Salif Biaye - main .png]]

3. voici le lien de l'app https://flask-heroku-appgit-an3gqfn7rvghctwbdckphm.streamlit.app/

## Conclusion et recommandations

### Points forts

- Utilisation d‚ÄôOptuna pour optimiser efficacement les hyperparam√®tres.
- Interface conviviale pour les utilisateurs non techniques.
- Mod√®le pr√©dictif robuste avec des m√©triques satisfaisantes.

### Am√©liorations possibles

- Int√©gration de nouvelles caract√©ristiques pour am√©liorer les performances.
- Augmentation du nombre de donn√©es d‚Äôentra√Ænement.
- Ajout d'une analyse plus pouss√©e des performances dans des sc√©narios r√©els.